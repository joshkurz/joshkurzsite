# Security Review: joshkurz.net

| Field | Value |
|-------|-------|
| Reviewed | 2026-02-28 |
| Commit | `72f0437f437b80e2ab6c042132bac285b6247c9e` |
| Commit date | 2026-02-28 23:06:15 -0500 |
| Commit message | Add pre-commit gate hook: tests + secret scan on every git commit |
| Reviewer | Claude (well-architected-security skill) |

---

## ðŸ”´ Critical Vulnerabilities

### 1. No rate limiting on cost-incurring endpoints â€” financial DoS

Every API call to these endpoints burns real money with zero friction:

```
POST /api/ai-joke       â†’ OpenAI API call (~$0.01+ each)
POST /api/custom-jokes  â†’ OpenAI moderation call + DynamoDB write
GET  /api/speak?text=â€¦  â†’ OpenAI TTS call (billed per character)
```

A loop of `curl -X POST https://joshkurz.net/api/ai-joke` could drain OpenAI credits overnight. `/api/speak` is worst because it accepts **GET** requests â€” meaning it can be triggered from any `<img src="/api/speak?text=...">` tag on any third-party page, with no CORS preflight.

No fix is in place. No Vercel rate-limit config, no `X-RateLimit` logic, no token bucket.

**Fix:** Add Vercel's built-in rate limiting via `vercel.json`, or use a middleware like `next-rate-limit`:
```json
{
  "functions": {
    "pages/api/ai-joke.js": { "maxDuration": 30 },
    "pages/api/speak.js": { "maxDuration": 30 }
  }
}
```
And enforce per-IP limits in the handlers or via Vercel's WAF.

---

### 2. `/api/speak` â€” unbounded text input billed per character

`pages/api/speak.js:7`
```js
const text = req.method === 'GET' ? req.query.text : req.body?.text;
// No length check before this:
const aiResponse = await openai.audio.speech.create({ input: text, ... })
```

An attacker sends `?text=` + 100KB of text. OpenAI TTS charges per character. No validation, no truncation, no error before the API call.

**Fix:**
```js
if (!text || typeof text !== 'string' || text.length > 500) {
  res.status(400).json({ error: 'Text must be 1â€“500 characters' })
  return
}
```

---

## ðŸŸ¡ Security Weaknesses

### 3. `.gitignore` won't catch a plain `.env` file

`/.gitignore:31`
```
.env*.local
```

This pattern matches `.env.local`, `.env.development.local` â€” but **not** `.env` or `.env.production`. If someone runs `cp .env.example .env` and fills in real keys, git will track it silently.

**Fix:**
```gitignore
.env
.env.*
!.env.example
```

### 4. `ratings.js` POST stores `joke` and `author` without size limits

`pages/api/ratings.js:69` â†’ `lib/ratingsStorageDynamo.js:19`
```js
await writeRating({ jokeId, rating: parsedRating, joke, author, mode, dateKey })
// In writeRating:
Item: { jokeText: joke || null, author: author || 'Unknown', ... }
```

`joke` and `author` from `req.body` have no length validation. An attacker can POST a 1MB `joke` string and it gets written to DynamoDB, inflating storage costs and polluting the dataset.

**Fix:**
```js
if (joke && typeof joke === 'string' && joke.length > 1000) {
  res.status(400).json({ error: 'Joke text too long' })
  return
}
```

### 5. `speak.js` â€” `voice` parameter passed to OpenAI without allowlist

`pages/api/speak.js:18`
```js
voice: voice || 'coral',
```

Any string is forwarded to OpenAI. OpenAI rejects invalid voices, but the error bubbles up and internal API details get logged server-side.

**Fix:**
```js
const VALID_VOICES = ['alloy', 'echo', 'fable', 'onyx', 'nova', 'shimmer', 'coral']
const safeVoice = VALID_VOICES.includes(voice) ? voice : 'coral'
```

### 6. `fast-xml-parser` â€” 4 CVEs via `@aws-sdk` (2 Critical)

From `npm audit`:
- `GHSA-m7jm-9gc2-mpf2` â€” entity encoding bypass via regex injection
- `GHSA-jmr7-xgp7-cmfj` â€” DoS via unlimited DOCTYPE entity expansion
- `GHSA-fj3w-jwp8-x2g3` â€” stack overflow in XMLBuilder
- `GHSA-37qj-frw5-hhjh` â€” RangeError DoS

Used via `@aws-sdk/xml-builder` â†’ `@aws-sdk/client-dynamodb`. Not directly user-triggerable (requires controlling AWS API responses), but flagged CVEs.

**Fix:** `npm audit fix` â€” non-breaking fix available.

### 7. 14 additional dependency vulnerabilities

```
2 critical  fast-xml-parser (above)
5 high      glob CLI injection (Jest only), json5 prototype pollution, semver ReDoS
7 moderate  @babel/runtime ReDoS, ajv ReDoS, brace-expansion ReDoS, word-wrap ReDoS, js-yaml prototype pollution
```

High/moderate ones are in test/build tooling (Jest, ESLint) â€” not production runtime. Low actual risk.

**Fix:** `npm audit fix` clears all 15 without breaking changes.

---

## ðŸŸ¢ Security Wins

- **No hardcoded secrets** â€” all credentials via `process.env`, never in source
- **No `.env` committed** â€” no credential files in git history
- **DynamoDB queries fully parameterized** â€” `ExpressionAttributeValues` throughout, no expression string concatenation
- **No `dangerouslySetInnerHTML`** â€” React JSX escapes all user-sourced content; XSS surface is clean
- **Custom joke field validation** â€” 3â€“500 char limits, type checking, trim (`custom-jokes.js:4-36`)
- **AI content moderation** before storing user submissions
- **Rating validation** â€” strict 1â€“5 integer enforcement
- **`/api/ai-joke` POST-only** â€” method guard in place, can't be triggered via link/img

---

## Immediate Actions Required

1. **Rate limit `/api/ai-joke`, `/api/speak`, `/api/custom-jokes`** â€” financial DoS with zero friction today
2. **Add text length cap to `/api/speak`** â€” currently unbounded, billed per character
3. **Run `npm audit fix`** â€” clears all 15 vulns, no breaking changes
4. **Fix `.gitignore`** â€” add `.env` and `.env.*` patterns

---

## Security Hardening Backlog

- Add `joke`/`author` size limits to `POST /api/ratings`
- Add `voice` allowlist to `/api/speak`
- Convert `/api/speak` to POST-only to prevent GET-based abuse from third-party pages
- Add Vercel WAF or `next-rate-limit` middleware
